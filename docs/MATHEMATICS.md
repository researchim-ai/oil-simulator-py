# Математические модели и численные методы

Этот раздел отвечает на вопрос «как именно программа считает». Сначала — интуитивное описание, затем более формальные формулы и, наконец, подробности AMG и линейного решателя.

---

## 1. Интуитивная картина

1. Мы разбиваем пласт на ячейки (контрольные объёмы).
2. Для каждой ячейки считаем, сколько нефти, воды и газа в ней содержится, и как они перетекают между ячейками.
3. Потоки определяются по закону Дарси: течёт туда, где давление ниже, и тем активнее, чем выше проницаемость и ниже вязкость.
4. На каждом временном шаге нужно найти новое давление (решаем уравнение на `p`), а затем обновить насыщающие фазы (явно).
5. Система уравнений на давление огромная — её решает AMG, умело «сжимая» задачу до грубых сеток и обратно.

---

## 2. Непрерывная модель

### 2.1 Баланс массы

Для каждой фазы `α ∈ {o, w, g}`:

$$
\frac{∂}{∂t} \left( φ ρ_α S_α \right)
+ \nabla \cdot \left( ρ_α \mathbf{u}_α \right) = q_α,
$$

где:

- `φ` — пористость,
- `ρ_α` — плотность (зависит от давления),
- `S_α` — насыщенность,
- `q_α` — источники/стоки (скважины),
- `\mathbf{u}_α` — скорость фильтрации.

### 2.2 Закон фильтрации (Дарси)

$$
\mathbf{u}_α = -\frac{k k_{r,α}(S)}{μ_α(p)} \Bigl( \nabla p_α - ρ_α g \nabla z \Bigr).
$$

Здесь `k` — абсолютная проницаемость, `k_{r,α}` — относительная, `μ_α` — вязкость, `g` — ускорение свободного падения.

### 2.3 Связь давлений фаз

Если капиллярное давление задействовано:

$$
p_w = p, \qquad
p_o = p + p_{cow}(S_w), \qquad
p_g = p - p_{cog}(S_g).
$$

В большинстве наших сценариев `p_{cow} = p_{cog} = 0`, поэтому все фазы имеют одинаковое давление.

---

## 3. Дискретизация: как из уравнений получаем матрицу

### 3.1 Метод контрольных объёмов (Finite Volume)

- Каждая ячейка `Ω_i` — контрольный объём.
- Потоки через грани вычисляются с помощью двухточечной схемы (TPFA).
- Для пары соседних ячеек `i` и `j` коэффициент проводимости (трансмиссивити):

$$
T_{ij} = \frac{2 A_{ij}}{Δx_i + Δx_j} \cdot \frac{k_{ij}}{μ_α},
$$

где `A_{ij}` — площадь грани, `Δx` — расстояние между центрами, `k_{ij}` — гармоническое среднее проницаемостей.

### 3.2 Схема IMPES

**IMPES (Implicit Pressure, Explicit Saturation)**:

1. Используем значения насыщенностей на предыдущем шаге, чтобы собрать уравнения на давление (они входят в `λ_t = Σ k_{r,α}/μ_α`).
2. Решаем имплицитную систему `A p^{n+1} = b`.
3. Зная новое давление и межфазные потоки, обновляем насыщенности явным шагом:

$$
S_α^{n+1} = S_α^n + \frac{Δt}{φ V_i} \Bigl( \sum_{грани} F_{α, ij} + q_{α,i} \Bigr),
$$

где `F_{α, ij}` — фазовый поток через грань.

### 3.3 Почему нужно решать линейную систему

Собрав уравнения для всех ячеек, получаем матрицу `A` (размер `N × N`, где `N` — число ячеек). Матрица разреженная: каждая строка содержит до 7–9 ненулевых элементов (соседи по сетке).

Свойства матрицы:

- симметричная и положительно определённая (SPD) при типичных настройках;
- состоит из вкладов суммарной подвижности `λ_t`, пористости, источников/стоков.

---

## 4. Линейный решатель: GMRES + AMG

### 4.1 Что такое предобуславливатель

Матрица может иметь очень разный масштаб коэффициентов — решение «в лоб» сходится медленно. Предобуславливатель `M⁻¹` помогает GMRES «увидеть» более простую систему `M⁻¹ A x = M⁻¹ b`, которая решается гораздо быстрее.

### 4.2 Classical AMG (Ruge–Stuben)

Основные шаги:

1. **Strong connections** — определяем, какие связи между ячейками действительно влияют на поведение (если `-a_{ij}` сравним с максимальным в строке, связь сильная).
2. **C/F splitting** — делим узлы на:
   - `C` (coarse) — попадут на грубую сетку,
   - `F` (fine) — будут интерполироваться через C-соседей.
3. **Построение пролонгации `P`**:
   - базовые RS-веса `w_{ij}^{RS} = -a_{ij}/a_{ii}`,
   - F–F коррекция для учёта влияния соседних точек,
   - energy-minimizing поправка: малые least-squares задачи на пространстве near-nullspace (константа, линейные градиенты),
   - нормировка, чтобы веса были неотрицательными и суммировались в 1.
4. **Restriction**: `R = Pᵀ` (традиционный выбор для SPD задач).
5. **Грубый оператор**: `A_c = Pᵀ A_f P` — вычисляется через блочное перемножение CSR матриц (`_csr_spmm`).
6. **Сглаживание**: на каждом уровне выполняем несколько итераций демпфированного Якоби (или другого метода), чтобы убрать высокочастотные ошибки.

### 4.3 Near-nullspace

AMG обязан точно воспроизводить медленно затухающие моды:

- константа,
- линейные градиенты `x`, `y`, `z`.

Они формируют базис, который мы ортонормализуем и используем в energy-minimizing этапе.

### 4.4 Объяснение V-цикла «на пальцах»

1. **Предсглаживание** — делаем несколько лёгких итераций, чтобы «снять шум».
2. **Спуск на грубый уровень** — считаем остаток `r = b - A x`, сжимаем его в меньшую систему через `R`.
3. **Рекурсивно решаем грубую задачу** (до тех пор, пока размер не станет небольшим — там можно использовать прямой решатель).
4. **Возвращаемся вверх** — интерполируем коррекцию `e_c` обратно: `x += P e_c`.
5. **Постсглаживание** — ещё немного разглаживаем результат, чтобы убрать артефакты интерполяции.

Один такой V-цикл сильно уменьшает ошибку; обычно хватает 2–6 циклов.

---

## 5. Реализация AMG в проекте

### 5.1 `_csr_spmm`

Наше перемножение CSR×CSR полностью лежит в PyTorch:

- обрабатываем матрицу блоками по 64 строк;
- формируем пары `(row, col)` в пределах блока и суммируем повторяющиеся значения через `scatter_add`;
- избегаем дорогостоящего `coalesce`, что снижает пик памяти.

### 5.2 Кэширование

При первом вызове решателя создаётся `ClassicalAMG` и сохраняется в `_AMG_CACHE`. Далее:

- если структура матрицы не меняется, мы просто обновляем значения (`update_matrix`);
- это позволяет выполнять множество временных шагов без перестройки иерархии.

### 5.3 Контроль качества

В логах выводятся:

- ошибка воспроизведения константы и градиента (`const_rel`, `grad_rel`);
- число отрицательных весов (ожидается 0);
- плотность матриц на каждом уровне;
- время на построение сильных связей, пролонгации и RAP.

Тест `tests/test_classical_amg_quality_on_laplacian` гарантирует, что после 3 V-циклов `grad_rel < 5·10⁻²`.

---

## 6. Сходимость и производительность

- GMRES с AMG предобуславливателем доводит относительную невязку до `10⁻³` за 3–6 циклов.
- На сетке 1e6 ячеек:
  - построение иерархии ≈ 216 секунд (GPU 24 ГБ, float64),
  - последующие шаги (с обновлением матрицы) ≈ 20–30 секунд.
- На меньших сетках (100×100×5) весь solve укладывается в единицы секунд.

---

## 7. Взгляд вперёд

Планируемые улучшения (важно для понимания дальнейших математических задач):

1. **Смешанная точность** — хранить грубые уровни в float32, сохранив точность на верхнем уровне.
2. **Альтернативный коэрснинг** (PMIS, smoothed aggregation), чтобы уменьшить число C-точек.
3. **JFNK** — использовать существующий AMG в качестве линейного предобуславливателя в полностью имплицитной схеме.
4. **Много-GPU** — распределять уровни по разным устройствам, что потребует новых операторов рестрикции/пролонгации.

---

## 8. Дополнительная литература

- Aziz, Settari. *Petroleum Reservoir Simulation.*
- Trottenberg et al. *Multigrid.*
- Kelley. *Iterative Methods for Linear and Nonlinear Equations.*

Эти книги дают больше математических подробностей и помогут углубиться в теорию, если текущего уровня объяснений недостаточно.

