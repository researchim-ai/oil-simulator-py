# Математические модели и численные методы

Этот раздел отвечает на вопрос «как именно программа считает». Сначала — интуитивное описание, затем более формальные формулы и, наконец, подробности AMG и линейного решателя.

---

## 1. Интуитивная картина

1. Мы разбиваем пласт на ячейки (контрольные объёмы).
2. Для каждой ячейки считаем, сколько нефти, воды и газа в ней содержится, и как они перетекают между ячейками.
3. Потоки определяются по закону Дарси: течёт туда, где давление ниже, и тем активнее, чем выше проницаемость и ниже вязкость.
4. На каждом временном шаге нужно найти новое давление (решаем уравнение на `p`), а затем обновить насыщающие фазы (явно).
5. Система уравнений на давление огромная — её решает AMG, умело «сжимая» задачу до грубых сеток и обратно.

---

## 2. Непрерывная модель

### 2.1 Баланс массы

Для каждой фазы $\alpha \in \{o, w, g\}$:

$$
\frac{\partial}{\partial t} \left( \phi \, \rho_\alpha S_\alpha \right)
+ \nabla \cdot \left( \rho_\alpha \mathbf{u}_\alpha \right) = q_\alpha,
$$

где:

- $\phi$ — пористость,
- $\rho_\alpha$ — плотность (зависит от давления),
- $S_\alpha$ — насыщенность,
- $q_\alpha$ — источники/стоки (скважины),
- $\mathbf{u}_\alpha$ — скорость фильтрации.

### 2.2 Закон фильтрации (Дарси)

$$
\mathbf{u}_\alpha = -\frac{k\, k_{r,\alpha}(S)}{\mu_\alpha(p)} \Bigl( \nabla p_\alpha - \rho_\alpha g \nabla z \Bigr).
$$

Здесь $k$ — абсолютная проницаемость, $k_{r,\alpha}$ — относительная, $\mu_\alpha$ — вязкость, $g$ — ускорение свободного падения.

### 2.3 Связь давлений фаз

Если капиллярное давление задействовано:

$$
p_w = p, \qquad
p_o = p + p_{cow}(S_w), \qquad
p_g = p - p_{cog}(S_g).
$$

В большинстве наших сценариев $p_{cow} = p_{cog} = 0$, поэтому все фазы имеют одинаковое давление.

---

## 3. Дискретизация: как из уравнений получаем матрицу

### 3.1 Метод контрольных объёмов (Finite Volume)

- Каждая ячейка $\Omega_i$ — контрольный объём.
- Потоки через грани вычисляются с помощью двухточечной схемы (TPFA).
- Для пары соседних ячеек $i$ и $j$ коэффициент проводимости (трансмиссивити):

$$
T_{ij} = \frac{2 A_{ij}}{\Delta x_i + \Delta x_j} \cdot \frac{k_{ij}}{\mu_\alpha},
$$

где $A_{ij}$ — площадь грани, $\Delta x$ — расстояние между центрами, $k_{ij}$ — гармоническое среднее проницаемостей.

### 3.2 Схема IMPES

**IMPES (Implicit Pressure, Explicit Saturation)**:

1. Используем значения насыщенностей на предыдущем шаге, чтобы собрать уравнения на давление (они входят в $\lambda_t = \sum k_{r,\alpha}/\mu_\alpha$).
2. Решаем имплицитную систему $A p^{n+1} = b$.
3. Зная новое давление и межфазные потоки, обновляем насыщенности явным шагом:

$$
S_\alpha^{n+1} = S_\alpha^n + \frac{\Delta t}{\phi V_i} \Bigl( \sum_{\text{faces } (i,j)} F_{\alpha, ij} + q_{\alpha,i} \Bigr),
$$

где $F_{\alpha, ij}$ — фазовый поток через грань.

### 3.3 Почему нужно решать линейную систему

Собрав уравнения для всех ячеек, получаем матрицу $A$ (размер $N \times N$, где $N$ — число ячеек). Матрица разреженная: каждая строка содержит до 7–9 ненулевых элементов (соседи по сетке).

Свойства матрицы:

- симметричная и положительно определённая (SPD) при типичных настройках;
- состоит из вкладов суммарной подвижности $\lambda_t$, пористости, источников/стоков.

---

## 4. Линейный решатель: GMRES + AMG

### 4.1 Что такое предобуславливатель

Матрица может иметь очень разный масштаб коэффициентов — решение «в лоб» сходится медленно. Предобуславливатель $M^{-1}$ помогает GMRES «увидеть» более простую систему $M^{-1} A x = M^{-1} b$, которая решается гораздо быстрее.

### 4.2 Classical AMG (Ruge–Stuben)

Основные шаги:

1. **Strong connections** — определяем, какие связи между ячейками действительно влияют на поведение (если $-a_{ij}$ сравним с максимальным в строке, связь сильная).
2. **C/F splitting** — делим узлы на:
   - `C` (coarse) — попадут на грубую сетку,
   - `F` (fine) — будут интерполироваться через C-соседей.
3. **Построение пролонгации `P`**:
   - базовые RS-веса $w_{ij}^{\text{RS}} = -\frac{a_{ij}}{a_{ii}}$,
   - F–F коррекция для учёта влияния соседних точек,
   - energy-minimizing поправка: малые least-squares задачи на пространстве near-nullspace (константа, линейные градиенты),
   - нормировка, чтобы веса были неотрицательными и суммировались в 1.
4. **Restriction**: $R = P^{\mathrm{T}}$ (традиционный выбор для SPD задач).
5. **Грубый оператор**: $A_c = P^{\mathrm{T}} A_f P$ — вычисляется через блочное перемножение CSR матриц (`_csr_spmm`).
6. **Сглаживание**: на каждом уровне выполняем несколько итераций демпфированного Якоби (или другого метода), чтобы убрать высокочастотные ошибки.

### 4.3 Near-nullspace

AMG обязан точно воспроизводить медленно затухающие моды:

- константа,
- линейные градиенты $x$, $y$, $z$.

Они формируют базис, который мы ортонормализуем и используем в energy-minimizing этапе.

### 4.4 Объяснение V-цикла «на пальцах»

1. **Предсглаживание** — делаем несколько лёгких итераций, чтобы «снять шум».
2. **Спуск на грубый уровень** — считаем остаток $r = b - A x$, сжимаем его в меньшую систему через $R$.
3. **Рекурсивно решаем грубую задачу** (до тех пор, пока размер не станет небольшим — там можно использовать прямой решатель).
4. **Возвращаемся вверх** — интерполируем коррекцию $e_c$ обратно: $x += P e_c$.
5. **Постсглаживание** — ещё немного разглаживаем результат, чтобы убрать артефакты интерполяции.

Один такой V-цикл сильно уменьшает ошибку; обычно хватает 2–6 циклов.

---

## 5. Реализация AMG в проекте

### 5.1 `_csr_spmm`

Наше перемножение CSR×CSR полностью лежит в PyTorch:

- обрабатываем матрицу блоками по 64 строк;
- формируем пары `(row, col)` в пределах блока и суммируем повторяющиеся значения через `scatter_add`;
- избегаем дорогостоящего `coalesce`, что снижает пик памяти.

### 5.2 Кэширование

При первом вызове решателя создаётся `ClassicalAMG` и сохраняется в `_AMG_CACHE`. Далее:

- если структура матрицы не меняется, мы просто обновляем значения (`update_matrix`);
- это позволяет выполнять множество временных шагов без перестройки иерархии.

### 5.3 Контроль качества

В логах выводятся:

- ошибка воспроизведения константы и градиента (`const_rel`, `grad_rel`);
- число отрицательных весов (ожидается 0);
- плотность матриц на каждом уровне;
- время на построение сильных связей, пролонгации и RAP.

Тест `tests/test_classical_amg_quality_on_laplacian` гарантирует, что после 3 V-циклов `grad_rel < 5·10⁻²`.

---

## 6. Сходимость и производительность

- GMRES с AMG предобуславливателем доводит относительную невязку до `10⁻³` за 3–6 циклов.
- На сетке 1e6 ячеек:
  - построение иерархии ≈ 216 секунд (GPU 24 ГБ, float64),
  - последующие шаги (с обновлением матрицы) ≈ 20–30 секунд.
- На меньших сетках (100×100×5) весь solve укладывается в единицы секунд.

---

## 7. Взгляд вперёд

Планируемые улучшения (важно для понимания дальнейших математических задач):

1. **Смешанная точность** — хранить грубые уровни в float32, сохранив точность на верхнем уровне.
2. **Альтернативный коэрснинг** (PMIS, smoothed aggregation), чтобы уменьшить число C-точек.
3. **JFNK** — использовать существующий AMG в качестве линейного предобуславливателя в полностью имплицитной схеме.
4. **Много-GPU** — распределять уровни по разным устройствам, что потребует новых операторов рестрикции/пролонгации.

---

## 8. Дополнительная литература

- Aziz, Settari. *Petroleum Reservoir Simulation.*
- Trottenberg et al. *Multigrid.*
- Kelley. *Iterative Methods for Linear and Nonlinear Equations.*

Эти книги дают больше математических подробностей и помогут углубиться в теорию, если текущего уровня объяснений недостаточно.

