# Математические модели и численные методы

## 1. Балансовые уравнения

### 1.1 Контрольный объём

Для каждой ячейки `Ωᵢ` записывается материальный баланс по фазам:

$$
\frac{∂}{∂t} \left( φ ρ_α S_α \right) + \nabla \cdot \left( ρ_α \mathbf{u}_α \right) = q_α,
$$

где `α ∈ {o, w, g}`, `φ` — пористость, `ρ_α` — плотность, `S_α` — насыщенность, `q_α` — источники/стоки (скважины).

### 1.2 Закон Дарси

$$
\mathbf{u}_α = -\frac{k k_{r,α}}{μ_α} \left( \nabla p_α - ρ_α g \nabla z \right),
$$

где `k` — абсолютная проницаемость, `k_{r,α}` — относительная, `μ_α` — вязкость, `g` — ускорение свободного падения.

### 1.3 Связь давлений

$$
p_w = p, \quad p_o = p + p_{cow}(S_w), \quad p_g = p - p_{cog}(S_g)
$$

В текущей конфигурации капиллярные давления часто равны нулю.

## 2. Дискретизация (IMPES)

- Давление рассчитывается имплицитно, насыщенности — явно (на основе обновлённого давления).
- Используется конечных объёмов схема с двухточечным флюксом (TPFA).
- Для флюксов между ячейками `i` и `j`:

$$
T_{ij} = \frac{2 k_{ij} A_{ij}}{μ_α (Δx_i + Δx_j)},
$$

где `k_{ij}` — гармоническое среднее проницаемостей, `A_{ij}` — площадь грань.

### 2.1 Имплицитный шаг давления

Суммируя по фазам, получаем уравнение на давление:

$$
\nabla \cdot \left( λ_t \nabla p \right) = \frac{1}{Δt} \left( φ \sum_{α} ρ_α S_α \right)^{n} - \frac{1}{Δt} \left( φ \sum_{α} ρ_α S_α \right)^{n+1,*} + \sum_{α} q_α,
$$

где `λ_t = Σ_α (k_{r,α} / μ_α)` — суммарная подвижность, `n+1,*` — оценка насыщенности после явного шага.

### 2.2 Линеаризация

- Давление линеаризуется по `p^{n+1}`.
- Получается линейная система `A x = b`, где `A` — симметричная положительно определённая матрица (SPD) с примерно 7 ненулевыми элементами в строке (трёхмерный 7-точечный опер).

## 3. Линейный решатель

### 3.1 Общая схема

- Основной решатель: GMRES (или CG для SPD) с предобуславливателем AMG.
- В `pressure_amg.py` `amg_solve` строит или достаёт из кэша экземпляр `ClassicalAMG`.

### 3.2 Classical Ruge–Stuben AMG

Компоненты реализации:

1. **Strong connections** — узлы `i` и `j` связаны, если
   $$
   -a_{ij} ≥ θ \max_{k≠i} (-a_{ik}),
   $$
   где `θ` настраивается (типично 0.2–0.25).

2. **C/F splitting** — алгоритм RS выбирает множество C-точек; остальные становятся F-точками. Выполняется жадная разметка на основе количества сильных зависимостей.

3. **Построение интерполяции (`P`)**
   - Базовые RS-веса: для F-точки `i` и соседей C-множества `j`:
     $$
     w_{ij}^{RS} = -\frac{a_{ij}}{a_{ii}}.
     $$
   - F–F коррекция: учитываются пути `i → m → j`, где `m` — сильные F-соседи.
   - Energy-minimizing поправка: смешение RS-весов с решением малой least-squares задачи в пространстве near-nullspace.
   - Нормировка: веса приводятся к сумме 1 и ограничиваются неотрицательностью.

4. **Restriction** — `R = Pᵀ`.

5. **Galerkin оператор** — `A_c = Pᵀ A_f P`, вычисляется через `_csr_spmm`.

6. **Сглаживатели**
   - Damped Jacobi с коэффициентом `ω` (адаптивный: 4/3 / ρ(D⁻¹A)).
   - Возможность переключения на Gauss-Seidel (для CPU).

### 3.3 Near-nullspace

Используется базис:

- Константа `1`.
- Три линейных градиента `x`, `y`, `z` (на основе координат центров ячеек).
- При необходимости добавляются квадратичные функции или сглаженные случайные векторы.

Базис ортонормализуется (`orthonormalize_columns`) перед решением задания энергии.

### 3.4 Построение RAP без выделения гигантского COO

- `_csr_spmm` реализует блочное CSR×CSR перемножение с уникализацией ключей `(row, col)` в пределах блока (без `coalesce`).
- Размер блока по умолчанию 64 строк, чтобы контролировать пиковую память.

### 3.5 Кэш и обновление матрицы

- Ключ кэша: `(shape, theta, max_levels, coarsest_size, device)`.
- Метод `update_matrix` перезаписывает значения `A` и переоценивает параметры сглаживания, не перестраивая структуру.

## 4. Псевдокод V-цикла

```
def v_cycle(level, rhs):
    if level == coarsest:
        return solve_direct(rhs)

    # предсглаживание
    x = smooth(level.A, rhs, iters=nu1)

    # вычисление остатка и рестрикция
    r = rhs - level.A @ x
    r_c = level.R @ r

    # рекурсивный V-цикл
    e_c = v_cycle(level+1, r_c)

    # пролонгация и коррекция
    x += level.P @ e_c

    # постсглаживание
    x = smooth(level.A, rhs, x, iters=nu2)
    return x
```

Типичные параметры: `nu1 = nu2 = 2`, процедура запускается 2–6 раз (V-циклы) до достижения относительного остатка < `tol`.

## 5. Критерии качества AMG

В `tests/test_classical_amg_quality_on_laplacian` проверяется снижение следующих ошибок после 3 V-циклов:

- `const_rel` — ошибка воспроизведения константы (< 5·10⁻⁴).
- `grad_rel` — ошибка градиентного режима (< 5·10⁻²).
- `rand_rel` — ошибка на случайном векторе (< 1·10⁻¹).

## 6. Сходимость и оценка

- На SPD системах GMRES+AMG достигает относительного остатка 10⁻³ за 3–6 V-циклов.
- Для 1e6 ячеек общее время на один шаг: 3.9 минуты (включая построение AMG ~216 с и 6 циклов smooth).
- Для последующих шагов (с тем же кэшем) линейный solve занимает 20–30 секунд (обновление матрицы + 2–3 V-цикла).

## 7. Будущие улучшения

- Поддержка смешанной точности (float32 на грубых уровнях).
- Альтернативные схемы коэрснинга (PMIS/SA) для уменьшения количества C-точек.
- Встраивание JFNK как внешнего нелинейного решателя с использованием существующего AMG как предобуславливателя линейного подзадачи.

